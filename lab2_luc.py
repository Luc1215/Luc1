# -*- coding: utf-8 -*-
"""lab2_Luc

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wAzJJirZwHswHJcW9-3xEFVh45R4uukP
"""

import numpy as np
import matplotlib.pyplot as plt

"""Label This"""

numbers= np.array([1,2,2,3,3,3,4,4,4,4]) # creating a array of numbers for numpy
plt.hist(numbers,100); # plotting a histogram up to 100

"""# PRNG

See Here!!
[PRNG Lab 2.5](https://colab.research.google.com/drive/1HUZPmRsPI6vNPKnMhgIvFpDS14AAP8w7?usp=sharing)
"""

x = 0.12345 # assigning a value to x

x = x*3 # x timing a number

x % 1 # x is one percent

current_point = 0.12345          # seed value
points_to_save = np.zeros(50000,)  # initialize an array of zeros

for i in __builtin__.range(points_to_save.shape[0]):
    current_point = 3*current_point % 1      # update x and store the value in X
    points_to_save[i] = current_point

plt.plot(points_to_save, '.')     # plot the values in X

plt.hist(points_to_save); # plot histogram

def coin(): # coin flip
    return 2*(np.random.random() > 0.5) - 1 # coin flip generator between number 0 to one if greater the 0.5 return one for head if not greater the 0.5 return -1 for tail

coin() # coin

x = 0 # assigning a value to x
x + coin() # the value for x plus the coin

x = 0 # assigning a value to x

for i in range(3): # i is a range of numbers
    x = x + coin() # calling a function for x

x # variable

x = 0 # assigning a value to x

for i in range(100): # i is a range of numbers
    x = x + coin() # calling a function for x

x # variable

M = 10000 # Number of repetitions
N = 100 # Number of coin flips in each repetition


X = np.zeros(M,) # array outcome

for j in range(M): # setting outcome to zero

    x = 0 # assigning a value to x

    for i in range(N): # flip coin and see outcome
        x = x + coin() #  flip coin and see outcome

    X[j] = x # see outcome results

plt.hist(X); # plot histogram



"""# Bonus: Explain Pascal's Triangle"""

P = np.zeros((12,18)) # importing numpy

P[0,5]=1 # set the values at row zero column 5

for i in range(1,P.shape[0]): # Starting at row 1

    for j in range(1,P.shape[1]-1): # last row not included

        P[i,j] = P[i-1,j-1]+P[i-1,j] # adding value from previous

print(P[:,5:]) # print p starting the six row

"""# Normal Distribution"""

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution
std_dev = 0.1  # Standard deviation (sigma) of the distribution

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 10000
data_points = np.random.normal(mean, std_dev, sample_size)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True)

x = np.linspace(-15,15,1000) # arrays from 1000 evenly space out from -15 to 15

y = np.exp(-x**2) # storing result of x squared

plt.plot(x,y) # plot

y2 = np.sin(10*x) # sin times 10 x

plt.plot(x,y2) # plot

plt.plot(x,y*y2) # plot

y3 =  np.exp(- (x - 0) ** 2 ) # starting the function at zero
plt.plot(x, y3, linewidth=2, color='r') # plot the function with colors

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution
std_dev = 0.1  # Standard deviation (sigma) of the distribution

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 10000
data_points = np.random.normal(mean, std_dev, sample_size)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True)

# Plot the probability density function of the normal distribution
normal_dist_curve = 1 / (std_dev * np.sqrt(2 * np.pi)) * np.exp(- (x - mean) ** 2 / (2 * std_dev ** 2))
plt.plot(x, normal_dist_curve, linewidth=2, color='r')

# Set the title and labels for the plot
plt.title('Normal Distribution Visualization')
plt.xlabel('Value')
plt.ylabel('Probability Density')

# Display the plot
plt.show()



x = np.array([1,2,3,4]) # array of sequence numbers

np.sum(x) # sum of array

x.shape[0] # shape of histogram

np.sum(x)/x.shape[0] # sum of histogram and the shape

def mean(x): # define x
    return np.sum(x)/x.shape[0] # sum of shape

mean(x) # x meaning

x # assigning a value to x

x - mean(x) # x - the mean

(x - mean(x))**2 # x - the mean 2 squared

def var(x): # Calculate the mean x
    return mean((x - mean(x))**2) # calculate the mean the take the square root

def std(x): # importing
    return np.sqrt(var(x)) # square root of the array

mean(x) # mean x

var(x) # variable

std(x) # standard deviation



"""### Uniform Random Numbers"""

X = np.random.random(500000,) # inputting a random value for x

X # x

plt.hist(X,100);

np.random.random() # numpy random

r = np.random.random() # numpy random

r # r

r = np.random.randint(1,10) # numpy random from 1 -10

r # r

np.random.randn() # random

numbers  = np.random.randn(2,4) # random from 2 to4

numbers.shape # shape

numbers = numbers.reshape(-1) # shape

numbers.shape # shape

numbers= np.array([1,2,2,3,3,3,4,4,4,4]) # array of numbers

plt.hist(numbers,100); # plot histogram up to 100

numbers = np.random.randn(100000,) # an array of 100000 random number
plt.hist(numbers,100); # histogram of 100

numbers = np.random.rand(1000000,) # an array of 100000 random number
plt.hist(numbers,100); # histogram of 100

np.random.seed(12345) # random
data = np.random.randn(2, 100) # random from 2 to 100

plt.figure(1, figsize=(9, 9)) # size 9 by 9

plt.subplot(2,2,1) # plot the first row
plt.hist(data[0]) # plot first row

plt.subplot(2,2,2) # scatter plot
plt.scatter(data[0], data[1]) # scatter plot

plt.subplot(2,2,3) # line plot
plt.plot(data[0], data[1],'-') # line plot

plt.subplot(2,2,4) # plot
plt.hist2d(data[0], data[1]) # 2d histogram

plt.show() # display plot

"""Normal Dist Data"""

x = 10*np.random.randn(10000) # random

plt.hist(x); # plot histogram

x = np.random.rand(1000,) # array random number of 1000

plt.hist(x); # plot histogram



mu = 0  # mean of distribution
sigma = 1  # standard deviation of distribution
x = mu + sigma * np.random.randn(10000) # random

n,bins,patches = plt.hist(x,bins=100) # plot histogram up to 100

bins

y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(y) # range of value of x

num_bins = 50 # histogram of date
n,bins,patches = plt.hist(x, num_bins, density=1) # plot histogram
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2)) # probability normal distribution
plt.plot(bins,y) # plot



x # x

def mean(x): # calculate sum of array
    return np.sum(x)/x.shape[0]. # divide the sum of the array

def var(x): # calculate the mean of the array
    return mean((x - mean(x))**2) # calculate the square root of elements of array

def std(x): # standard deviation
    return np.sqrt(var(x)) # calculate the square root

def median(x): # median
    n = len(x) # len
    sorted_x = np.sort(x) # sort the array x
    mid = n // 2 # calculate the index of the middle element
    if n % 2 == 0: # if even
        return (sorted_x[mid - 1] + sorted_x[mid]) / 2 # return the of the elements
    else: # if odd
        return sorted_x[mid] # return the middle element

def mode(x): # mode
    values, counts = np.unique(x, return_counts=True) # value
    max_count_index = np.argmax(counts) # index of max count
    return values[max_count_index] # corresponding to the max count

def range1(x): # range
    return np.max(x) - np.min(x) # find the max and min value of the array

data = np.array([1, 2, 2, 3, 4, 5, 5, 5, 6]) # date of array

# Testing the functions
mean_value = mean(data)
var_value = var(data)
std_value = std(data)
median_value = median(data)
mode_value = mode(data)
range_value = range1(data)

mean_value, var_value, std_value, median_value, mode_value, range_value # display result



"""# Homework



"""



"""# Pi from Random Numbers"""

N = 10 # n is 10

points = -1 + 2*np.random.random((N,2))  # random point

points # points

plt.plot(points[:,0],points[:,1],'.') # plot

plt.gca().set_aspect(1) # plot

inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1 # determine point in the inside
outside_circle = points[:,0]**2 + points[:,1]**2  > 1 # determine point in the outside

plt.plot(points[inside_circle,0],points[inside_circle,1],'g.') # plot point inside
plt.plot(points[outside_circle,0],points[outside_circle,1],'r.') # plot point outside


plt.gca().set_aspect(1) # ratio plot

np.sum(inside_circle),np.sum(outside_circle) # display point insisde and outside

total_area = 4 # total area

fraction_inside = np.sum(inside_circle)/N # calculate the point insed and outside the circle

fraction_inside*total_area # calculate unit circle

N = 100000000 # total number of random point
points = -1 + 2*np.random.random((N,2)) # generate random number
inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1 # determine which point is inside the circle
fraction_inside = np.sum(inside_circle)/N # calculate the fraction inside the circle
fraction_inside*4 # times 4

"""# Complete Code for Estimating π using Monte Carlo Simulation"""

# Number of random points to generate
num_points = 10000

# Generating random points
x_points = np.random.uniform(-1, 1, num_points)
y_points = np.random.uniform(-1, 1, num_points)

# Calculating the number of points inside the quarter circle
points_inside = np.sqrt(x_points**2 + y_points**2) <= 1
num_inside = np.sum(points_inside)

# Estimating π
pi_estimate = 4 * num_inside / num_points

# Plotting the points and the quarter circle
plt.figure(figsize=(6, 6))
plt.scatter(x_points[points_inside], y_points[points_inside], color='green', label='Inside')
plt.scatter(x_points[~points_inside], y_points[~points_inside], color='red', label='Outside')
circle = plt.Circle((0, 0), 1, color='blue', fill=False)
plt.gca().add_artist(circle)
plt.title('Estimating π using Monte Carlo Simulation')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.axis('equal')
plt.show()

pi_estimate



"""# e from Random Numbers"""

X = np.random.random((1000000,10)) # random

Y = np.cumsum(X,1) # sum

Z = np.argmax(Y > 1,1) + 1 # max

np.mean(Z) # mean

np.mean(np.argmax(np.cumsum(np.random.random((10000000,10)),1) > 1,1) + 1) # mean

np.exp(1) # exponent

"""# Further Reading:

### Quantum Random Numbers API

https://aws.amazon.com/marketplace/pp/prodview-246kyrfjo3bag
"""